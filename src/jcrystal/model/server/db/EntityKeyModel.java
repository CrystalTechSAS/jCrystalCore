package jcrystal.model.server.db;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import jcrystal.annotations.internal.model.db.InternalEntityKey;
import jcrystal.entity.types.ConstantId;
import jcrystal.reflection.annotations.CrystalDate;
import jcrystal.reflection.annotations.EntityKey;
import jcrystal.reflection.annotations.jEntity;
import jcrystal.reflection.annotations.security.Base;
import jcrystal.server.databases.DBUtils;
import jcrystal.types.IJType;
import jcrystal.types.JType;
import jcrystal.types.JVariable;
import jcrystal.utils.StringUtils;
import jcrystal.utils.langAndPlats.AbsICodeBlock;

public class EntityKeyModel {
	private static final Class<?>[] VALID_KEY_TYPES = {Long.class, long.class, String.class, Date.class, ConstantId.class};
	public static boolean isValidKeyType(IJType type) {
		return type.is(VALID_KEY_TYPES) || type.isJAnnotationPresent(CrystalDate.class) || type.isAnnotationPresent(jEntity.class);
	}
	
	List<EntityField> llaves = new ArrayList<>();
	EntityClass padre;
	private IJType singleKeyType;
	public EntityKeyModel(EntityClass padre, List<EntityField> campos) {
		this.padre = padre;
		for (EntityField campo : campos) {
			JVariable f = campo.f;
			if (f.isAnnotationPresent(EntityKey.class)) {
				if(isValidKeyType(f.type()))
					llaves.add(campo);
				else
					throw new NullPointerException("Invalid key type for " + padre.name()+" on " + f.name() + ":" +f.type());
			}
		}
		
	}
	public void configureParentKey(EntityClass parentAncestor) {
		if(parentAncestor != null){
			llaves.addAll(0, parentAncestor.key.llaves);
		}
		if(llaves.isEmpty() && padre.mainDBType.type.allowsAutogeneratedKeys()) {
			EntityField generatedKey = new EntityField(DBUtils.generatedDummyKey(padre, padre.mainDBType.type), padre.mainDBType.type);
			llaves.add(generatedKey);
			padre.fields.add(generatedKey);
			padre.properties.add(generatedKey);
		}
	}

	public boolean isAutogeneratedKey() {
		return llaves.get(llaves.size() - 1).isAutogenerated();
	}
	
	public String getKeyValues() {
		return llaves.stream().filter(f->!f.isConstant).map(f->f.fieldName()).collect(Collectors.joining(", "));
	}
	
	public List<IJType> getKeyTypes() {
		return llaves.stream().map(f->f.type()).collect(Collectors.toList());
	}
	public String getKeyNullCheck() {
		return llaves.stream().filter(f->!f.isPrimitive()).map(f->"null == " + f.fieldName()).collect(Collectors.joining("||"));
	}
	public List<EntityField> getLlaves() {
		return llaves;
	}
	public boolean isSimple() {
		return llaves.size() == 1;
	}
	public String getKeyTypes(AbsICodeBlock code) {
		return llaves.stream().map(f->{
			if(f.type().isPrimitive())
				return code.$(code.$convert(f.type().getObjectType()));
			else if(f.keyData == null || f.getTargetEntity() == null)
				return code.$(code.$convert(f.type()));
			else if(f.getTargetEntity().key.isSimple())
				return code.$(f.getTargetEntity().key.getLlaves().get(0).type());
			else
				return code.$(f.getTargetEntity().key.getLlaves().get(0).type());
		}).collect(Collectors.joining(", "));
	}
	public Stream<EntityField> stream(){
		return llaves.stream();
	}
	public static class SaltTransformer implements Function<EntityField, String>{
		public static final SaltTransformer INSTANCE = new SaltTransformer();
		private SaltTransformer() {
			// TODO Auto-generated constructor stub
		}
		@Override
		public String apply(EntityField f) {
			if(f.hashSalt!=null && f.type().is(String.class)) {
				if(f.hashSalt.base() == Base.BASE32)
					return "new org.apache.commons.codec.binary.Base32().encodeToString(hash"+StringUtils.capitalize(f.fieldName())+"(" + f.fieldName() + "))";
				else
					return "java.util."+f.hashSalt.base().name().replace("BASE","Base")+".getEncoder().encodeToString(hash"+StringUtils.capitalize(f.fieldName())+"(" + f.fieldName() + "))";
			}
			return f.fieldName();
		}
	}
	
	public IJType getSingleKeyType(IJType complexKeyType) {
		if(llaves.size() == 1)
			return llaves.get(0).type();
		else
			return complexKeyType;
	}
	public IJType getSingleKeyType() {
		if(singleKeyType == null) {
			if(llaves.size() == 1)
				singleKeyType = llaves.get(0).type();
			else {
				singleKeyType = new JType(null, padre.clase.name()+".Key");
				singleKeyType.addAnnotation(new InternalEntityKey(padre.clase.getSimpleName()+".Key", padre.clase));
			}
		}
		return singleKeyType;
	}
	public int size() {
		return llaves.size();
	}
	public Stream<EntityField> parent(){
		return stream().limit(size() - 1);
	}
	public EntityField getLast() {
		return llaves.get(llaves.size() - 1);
	}
}
